Rooshil Patel
1255318
Assignment 2
CMPUT 379

Question 0:
Of the three servers, I was only able to implement two of them (server_f and server_p). Between these two servers, I found that server_f was the hardest to implement as it required a huge array of additional functions as well as understanding how the connection worked, how to properly read from the client and how to properly output to the client. This also required the implementation of the checking system for the different error responses that we send out depending on the request. In comparison, the pthreads server was much simpler to implement, as it was just adapted from the fork server. I believe the first server implemented would most likely be the hardest.

Question 1:
Between server_f and server_p, the more efficient system would be server_p. The reasoning behind this is due to the fact that when server_f forks into a parent and child process, the child process has a new copy of all virtual memory allocated to the parent. The amount of memory used then increases signifncatly as connections increase. The fork server, however, has the benefit of killing crashed processes, whereas the pthreads server does not, possibly allowing resources and files to be locked by a crashed thread.
If the system running is running a powerfule server with a large ammount of incoming connections, it would be favorable to use a forking server for increased stability against possible errors and crashes. If the system is not as powerful, using a pthread approach would be able to maximize the number of connections to the server with the least amount of overhead. The downside to this is if a thread crashes, those resources may remain locked until the process is restarted.

Question 2:
Server_p's and server_s's efficiency depends mostly on the hardware the server is running on. If we are using a single core server, the select server approach would be the most efficient, especially if there are multiple incoming connections. This is because the pthread implementation would run into the problem of multiple context switches. As the number of connections grow, the number of context switches increases, possibly causing a backlog depending on the computing time required for each request. The select server also has a significant advantage on embedded systems which lack thread pausing. However, select servers' come with the flaw that any crash or bug would cause the entire server to be brought down. As each task is not executed separately from the main thread, any fault or crash causes the entire process to hang or exit. Pthreads, in this particular situation, would be slightly more reliable, as while the crashing thread may lock up resources and/or files, it does not bring the entire process down. As well, if the server is running on a fast(er) single core processor (or one with optimized context switching) or on any form of multiprocessor/multi-threaded machine, then the pthreads server would be significantly more efficient as well as a bit safer.
